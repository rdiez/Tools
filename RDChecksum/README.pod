This file is written in Perl's Plain Old Documentation (POD) format
and has been generated with option --help-pod .
Run the following Perl commands to convert it to HTML or to plain text for easy reading:

  pod2html README.pod >README.html
  pod2text README.pod >README.txt


=head1 OVERVIEW

RDChecksum version 0.58

Creates or verifies a list of file checksums (hashes).

=head1 RATIONALE

In an ideal world, all filesystems would have integrated data checksums like ZFS does.
This tool is a poor man's substitute for such filesystem-level checksums.
It can also help detect data corruption when transferring files over a network.

Storage devices are supposed to use checksums to detect or even correct data errors,
and most data transport protocols should do the same. However, computer systems are becoming
more complex and more brittle at the same time, often due to economic pressure.

As a result, I have very rarely performed a large backup or file copy operation without hitting some data
integrity issue. For example, interrupting with Ctrl+C an rsync transfer to an SMB network share
tends to corrupt the destination files, and resuming the transfer will not fix such corruption.

There are many alternative checksum/hash tools around, but I decided to write a new one out of frustration
with the existing software. Advantages of this tool are:

=over

=item *

Resumable verification.

I often verify large amounts of data on conventional hard disks, and it can take hours to complete.
But sometimes I need to interrupt the process, or perhaps I inadvertently close the wrong terminal window.
All other checksum tools I know will then restart from scratch, which is very annoying, as it is
an unnecessary waste of my precious time.

See option I<< --resume-from-lineS< > >>.

=item *

It is possible to automate the processing of files that failed verification.

The verification report file has a legible but strict data format. An automated tool
can parse it and, for example, copy all failed files again.

=back

For disadvantages and other issues see the CAVEATS section below.

=head1 USAGE

 ./rdchecksum.pl --create [options] [--] [directory]
 ./rdchecksum.pl --verify [options]

Argument 'directory' is optional and defaults to the current directory ('.').

If 'directory' is the current directory ('.'), then the filenames in the checksum list will be like 'file1.txt'.
Otherwise, the filenames will be like 'directory/file1.txt'.

The checksum file itself (FileChecksums.txt by default) and any other temporary files with that basename
will be automatically skipped from the checksum list (assuming that the checksum filename's basedir and
argument 'directory' match, because mixing relative and absolute paths will confuse the script).

Usage examples:

 cd some-directory && /somewhere/rdchecksum.pl --create

 cd some-directory && /somewhere/rdchecksum.pl --verify

Command-line options are read from environment variable I<< RDCHECKSUM_OPTIONS >> first, and then from the command line.

=head1 OPTIONS

=over

=item *

B<-h, --help>

Print this help text.

=item *

B<--help-pod>

Preprocess and print the POD section. Useful to generate the README.pod file.

=item *

B<--version>

Print this tool's name and version number (0.58).

=item *

B<--license>

Print the license.

=item *

B<-->

Terminate options processing. Useful to avoid confusion between options and filenames
that begin with a hyphen ('-'). Recommended when calling this script from another script,
where the filename comes from a variable or from user input.

=item *

B<< --create  >>

Creates a checksum file.

When creating a checksum file named F<< FileChecksums.txt >>S< >, a temporary file named F<< FileChecksums.txt.inProgress >>
will also be created. If this script is interrupted, the temporary file will remain behind.

=item *

B<< --verify  >>

Verifies the files listed in the checksum file.

A report file named F<< FileChecksums.txt.verification.report >> will be created. Only failed files will show up in the report.

It is possible to parse the report in order to automatically process the files that failed verification.

Temporary files F<< FileChecksums.txt.verification.resume >> and
F<< FileChecksums.txt.verification.resume.tmp >> will be created and may remain behind if the script gets killed.
See I<< --resume-from-line >> for more information.

=item *

B<< --checksum-file=filename >>

The default filename is F<< FileChecksums.txtS< > >>.

=item *

B<< --resume-from-line=n >>

Before starting verification, skip (nS< >-S< >1) text lines at the beginning of F<< FileChecksums.txt >>S< >.
This (rather crude) option allows you to manually resume a previous, unfinished verification.

During verification, file F<< FileChecksums.txt.verification.resume >> is created and periodically updated
with the latest verified line number. The update period is one minute. In order to guarantee an atomic update,
temporary file F<< FileChecksums.txt.verification.resume.tmp >> will be created and then moved
to the final filename.

If verification is completed, F<< FileChecksums.txt.verification.resume >> is automatically deleted, but
if verification is interrupted, F<< FileChecksums.txt.verification.resume >> will remind behind
and will contain the line number you can resume from. It the script gets suddenly killed and cannot gracefully stop,
the line number in that file will lag up to the update period, and the temporary file might also be left behind.

Before resuming, remember to rename or copy the last report file (should you need it), because it will be overwritten,
so you will then lose the list of files that had failed the previous verification attempt.

=item *

B<< --verbose >>

Print each filename during processing.

=back

=head1 EXIT CODE

Exit code: 0 on success, some other value on error or if interrupted by a signal.

=head1 SIGNALS

Reception of signals SIGTERM, SIGINT (usually Ctrl+C) and SIGHUP (usually closing the terminal window) make this
script gracefully stop. Most other signals will kill the script straight away.

SIGHUP will probably not be handled as a normal request to stop if you close the terminal,
because writing to sdtout or stderr will fail immediately and will make this script
quit beforehand.

=head1 USING I<< background.sh >>

It is probably most convenient to run this tool with another script of mine called I<< background.sh >>S< >,
so that it runs with low priority and you get a visual notification when finished.

The optional memory limit below reduces the performance impact on other processes by preventing
the checksum operation from flushing the complete Linux filesystem cache. For example:

 export BACKGROUND_SH_LOW_PRIORITY_METHOD="systemd-run"
 cd some-directory
 background.sh --memory-limit=512M /somewhere/rdchecksum.pl --verify

=head1 CHECKSUM FILE

The generated file with the list of checksums looks like this:

 2019-12-31T20:15:01.200  CRC-32  12345678  1,234,567  subdir/file1.txt
 2019-12-31T20:15:01.300  CRC-32  90ABCDEF  2,345,678  subdir/file2.txt

=head1 CAVEATS

=over

=item *

This tool is rather simple at the moment.

For example, the only checksum type supported at the moment ist CRC-32 from I<< zlibS< > >>.

If you need more features, drop me a line.

=item *

The granularity level is one file.

If you data consists of a single, huge file, you will not be able to resume an interrupted verification.

=item *

Processing is single threaded.

If you have a very fast SSD and a multicore processor, you will probably be waiting longer than necessary.

=item *

There is no symbolic link loop detection (protection against circular links).

In such a situation, this tool will run forever.

=back

=head1 FEEDBACK

Please send feedback to rdiezmail-tools at yahoo.de

=head1 LICENSE

Copyright (C) 2020 R. Diez

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License version 3 as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License version 3 for more details.

You should have received a copy of the GNU Affero General Public License version 3
along with this program.  If not, see L<http://www.gnu.org/licenses/>.

=cut
